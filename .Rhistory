ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
w <- model$par
Pred.0 <- PRED%*%w
print(auc(y, as.vector(Pred.0)))
Pred.t <- PRED.t%*%w
print(auc(y.t, as.vector(Pred.t)))
setwd("H:/UbuntuRv2/Gibbs-sampler-algorithm/MA-Tingjin5")
### linear case 1 - (CV-MA)
#ensure empty environment
rm(list = ls())
library(pROC)
library(MASS)
set.seed(101)
#simulation set up
#200 train samples and 200 test samples with 1000 predictors
n <- 500
p <- 1000
rho <- 0.5
#correlation matrix
#correlation between any two predictors is 0.5 except x4,x5
M1   <- rho + (1-rho)*diag(p/2)
#correlation between x4 and others is 1/sqrt(0.5) except x5
M1[,4]  <- 1/sqrt(2)
M1[4,]  <- 1/sqrt(2)
M1[4,4] <- 1
M2 <- diag(1,p/2)
for (i in 1:p/2)
{
for (j in 1:i)
{
M2[j,i] <- rho^{i-j}
M2[i,j] <- M2[j,i]
}
}
#coefficients
#with 4 preselected equal = 1 and others are randomly generated from N(0,1)
s <- 10
beta <- 2*c(1,1,1,1,1, rnorm(s-5))
AUC <- vector()
j <- 0
while(j < 100){
#data matrix
x1 <- mvrnorm(n,rep(0,p/2),M1)
x2 <- mvrnorm(n,rep(0,p/2),M2)
AX <- cbind(x1,x2)
w <- 2 + AX[,c(1:4,1:6+p/2)]%*%beta + sin(rnorm(n)*pi) + cos(rnorm(n)*pi)
q <- exp(w)/(1+exp(w))
y <- rbinom(n,1,q)
p <- PP <- ncol(AX)
######################################
COV <- rep(0,len=PP)
for(i in 1:PP){
fit <- glm(y~AX[,i],family=binomial())
COV[i] <- (summary(fit)$coefficients)[2,4]
}
a <- cbind(1:PP,COV)
COV <- a[order(a[,2],decreasing=F),1:2]
#print(COV)
NN <- NumbPred <- 10 #The number of predictors
#KK <- trunc(sum(COV[,2]<=0.01)/NN)
KK <- 10
print(c(NN,KK))
######################################
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
}
######################################
w <- rep(0.5,len=KK)
print(head(Pred))
print(auc(y, Pred[,1]))
print(auc(y, Pred[,2]))
print(cor.test(y, Pred[,1]))
print(cor.test(y, Pred[,2]))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
w <- model$par
######################################
Pred <- PRED%*%w
EProb <- exp(Pred)/(1+exp(Pred))
AUC <- c(AUC, auc(y, EProb))
j <- j+1
print(j)
}
AUC <- vector()
j <- 0
while(j < 100){
#data matrix
x1 <- mvrnorm(n,rep(0,p/2),M1)
x2 <- mvrnorm(n,rep(0,p/2),M2)
AX <- cbind(x1,x2)
w <- 5 + AX[,c(1:4,1:6+p/2)]%*%beta + sin(rnorm(n)*pi) + cos(rnorm(n)*pi)
q <- exp(w)/(1+exp(w))
y <- rbinom(n,1,q)
p <- PP <- ncol(AX)
######################################
COV <- rep(0,len=PP)
for(i in 1:PP){
fit <- glm(y~AX[,i],family=binomial())
COV[i] <- (summary(fit)$coefficients)[2,4]
}
a <- cbind(1:PP,COV)
COV <- a[order(a[,2],decreasing=F),1:2]
#print(COV)
NN <- NumbPred <- 10 #The number of predictors
#KK <- trunc(sum(COV[,2]<=0.01)/NN)
KK <- 10
print(c(NN,KK))
######################################
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
}
######################################
w <- rep(0.5,len=KK)
print(auc(y, Pred[,1]))
print(auc(y, Pred[,2]))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
w <- model$par
######################################
Pred <- PRED%*%w
EProb <- exp(Pred)/(1+exp(Pred))
AUC <- c(AUC, auc(y, EProb))
j <- j+1
print(j)
}
COV[1:50]
cor(y, x[,5])
cor(y, AX[,4])
cor(y, AX[,3])
cor(y, AX[,2])
cor(y, AX[,1])
a[1:20,]
t(a[1:100,])
summary(glm(y~AX[,1], binomial()))
sum(y)
j <- 0
while(j < 10){
#data matrix
x1 <- mvrnorm(n,rep(0,p/2),M1)
x2 <- mvrnorm(n,rep(0,p/2),M2)
AX <- cbind(x1,x2)
w <- -5 + AX[,c(1:4,1:6+p/2)]%*%beta + sin(rnorm(n)*pi) + cos(rnorm(n)*pi)
q <- exp(w)/(1+exp(w))
y <- rbinom(n,1,q)
p <- PP <- ncol(AX)
######################################
COV <- rep(0,len=PP)
for(i in 1:PP){
fit <- glm(y~AX[,i],family=binomial())
COV[i] <- (summary(fit)$coefficients)[2,4]
}
a <- cbind(1:PP,COV)
COV <- a[order(a[,2],decreasing=F),1:2]
#print(COV)
NN <- NumbPred <- 10 #The number of predictors
#KK <- trunc(sum(COV[,2]<=0.01)/NN)
KK <- 10
print(c(NN,KK))
######################################
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
}
######################################
w <- rep(0.5,len=KK)
print(auc(y, Pred[,1]))
print(auc(y, Pred[,2]))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
w <- model$par
######################################
Pred <- PRED%*%w
EProb <- exp(Pred)/(1+exp(Pred))
AUC <- c(AUC, auc(y, EProb))
j <- j+1
print(j)
}
### linear case 1 - (CV-MA)
#ensure empty environment
rm(list = ls())
library(pROC)
library(MASS)
#simulation set up
#200 train samples and 200 test samples with 1000 predictors
n <- 500
p <- 1000
rho <- 0.5
#correlation matrix
#correlation between any two predictors is 0.5 except x4,x5
M1   <- rho + (1-rho)*diag(p/2)
#correlation between x4 and others is 1/sqrt(0.5) except x5
M1[,4]  <- 1/sqrt(2)
M1[4,]  <- 1/sqrt(2)
M1[4,4] <- 1
M2 <- diag(1,p/2)
for (i in 1:p/2)
{
for (j in 1:i)
{
M2[j,i] <- rho^{i-j}
M2[i,j] <- M2[j,i]
}
}
#coefficients
#with 4 preselected equal = 1 and others are randomly generated from N(0,1)
s <- 10
beta <- 2*c(1,1,1,1,1, rnorm(s-5))
AUC <- vector()
#data matrix
x1 <- mvrnorm(n,rep(0,p/2),M1)
x2 <- mvrnorm(n,rep(0,p/2),M2)
AX <- cbind(x1,x2)
w <- AX[,c(1:4,1:6+p/2)]%*%beta + 3*sin(rnorm(n)*pi) + 3*cos(rnorm(n)*pi)
q <- exp(w)/(1+exp(w))
y <- rbinom(n,1,q)
p <- PP <- ncol(AX)
COV <- rep(0,len=PP)
for(i in 1:PP){
fit <- glm(y~AX[,i],family=binomial())
COV[i] <- (summary(fit)$coefficients)[2,4]
}
a <- cbind(1:PP,COV)
COV <- a[order(a[,2],decreasing=F),1:2]
NN <- NumbPred <- 10 #The number of predictors
#KK <- trunc(sum(COV[,2]<=0.01)/NN)
KK <- 10
print(c(NN,KK))
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
}
w <- rep(0.5,len=KK)
print(auc(y, Pred[,1]))
print(auc(y, Pred[,2]))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w)) + 1e-6
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
if(Pi==1){
Pi = Pi - 1e-6
}
else Pi = Pi + 1e-6
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
if(sum(Pi==1)>0){
Pi = Pi - 1e-6
}
else Pi = Pi + 1e-6
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
load("H:/UbuntuRv2/IBGS/test.RData")
setwd("H:/UbuntuRv2/IBGS/IBGS")
remove.packages(IBGS)
source('H:/UbuntuRv2/IBGS/IBGS/R/gibbs.R', echo=TRUE)
source('H:/UbuntuRv2/IBGS/IBGS/R/gibbs.R', echo=TRUE)
devtools::check()
devtools::check()
devtools::check()
devtools::build()
devtools::install()
library(IBGS)
devtools::build()
devtools::check()
devtools::check()
devtools::check()
devtools::build()
load("H:/UbuntuRv2/IBGS/test1.RData")
View(m.l1)
v <- m.l1$m.sic
n <- length(v)
n.half <- n/2
v.min    <- min(v)
v.sd     <- sd(v)
v.mean   <- mean(v)
v.upper  <- v.min + sqrt(10)*sqrt(v.sd^2 + (v.mean - v.min)^2)
v.min.half   <- min(v[1:n.half])
v.sd.half    <- sd(v[1:n.half])
v.mean.half  <- mean(v[1:n.half])
v.upper.half <- v.min.half + sqrt(10)*sqrt(v.sd.half^2 + (v.mean.half - v.min.half)^2)
plot(1:n, v, type = "l")
plot(1:n, v, type = "l", xlab = "Generations", ylab = "Values")
abline(h = v.upper, col = "red", lty = 2)
abline(h = v.upper.half, col = "red", lty = 2)
abline(h = v.upper.half, col = "blue", lty = 2)
abline(h = v.upper.half, col = "blue", lty = 3)
abline(h = v.upper.half, col = "blue", lty = 4)
abline(h = v.upper.half, col = "blue", lty = 5)
abline(h = v.upper.half, col = "blue", lty = 1)
abline(h = v.upper.half, col = "blue", lty = 3)
plot(1:n, v, type = "l", xlab = "Generations", ylab = "Values")
abline(h = v.upper, col = "red", lty = 2)
abline(h = v.upper.half, col = "blue", lty = 3)
plot(1:n, v, type = "l", xlab = "Generations", ylab = "Values")
abline(h = v.upper,  col = "red", lty = 2)
abline(h = v.upper.half, xlim=c(0,n.half), col = "blue", lty = 3)
lines(1:n.half, v.upper )
lines(1:n.half, rep(v.upper, n.half) )
plot(1:n, v, type = "l", xlab = "Generations", ylab = "Values")
lines(1:n.half, rep(v.upper.half, n.half), col = "red",  lty = 3 )
lines(1:n,      rep(v.upper, n),           col = "blue", lty = 2 )
plot(1:n, v, type = "l", xlab = "Generations", ylab = "Values",
main = "I-chart for the generated sequence")
lines(1:n.half, rep(v.upper.half, n.half), col = "red",  lty = 3 )
lines(1:n,      rep(v.upper, n),           col = "blue", lty = 2 )
ichart.Gibbs <- function(result){
v <- result$m.sic
n <- length(v)
n.half <- n/2
v.min    <- min(v)
v.sd     <- sd(v)
v.mean   <- mean(v)
v.upper  <- v.min + sqrt(10)*sqrt(v.sd^2 + (v.mean - v.min)^2)
v.min.half   <- min(v[1:n.half])
v.sd.half    <- sd(v[1:n.half])
v.mean.half  <- mean(v[1:n.half])
v.upper.half <- v.min.half + sqrt(10)*sqrt(v.sd.half^2 + (v.mean.half - v.min.half)^2)
plot(1:n, v, type = "l", xlab = "Generations", ylab = "Values",
main = "I-chart for the generated sequence")
lines(1:n.half, rep(v.upper.half, n.half), col = "red",  lty = 3 )
lines(1:n,      rep(v.upper, n),           col = "blue", lty = 2 )
}
ichart.Gibbs(m.l1)
ichart.Gibbs(m.l1)
ichart.Gibbs(m.s1)
paste("A","B", "C")
plot(1:n, v, type = "l", xlab = "Generations", ylab = "Values",
main = paste("I-chart for the generated", result$info, "sequence"))
ichart.Gibbs <- function(result){
v <- result$m.sic
n <- length(v)
n.half <- n/2
v.min    <- min(v)
v.sd     <- sd(v)
v.mean   <- mean(v)
v.upper  <- v.min + sqrt(10)*sqrt(v.sd^2 + (v.mean - v.min)^2)
v.min.half   <- min(v[1:n.half])
v.sd.half    <- sd(v[1:n.half])
v.mean.half  <- mean(v[1:n.half])
v.upper.half <- v.min.half + sqrt(10)*sqrt(v.sd.half^2 + (v.mean.half - v.min.half)^2)
plot(1:n, v, type = "l", xlab = "Generations", ylab = "Values",
main = paste("I-chart for the generated", result$info, "sequence"))
lines(1:n.half, rep(v.upper.half, n.half), col = "red",  lty = 3 )
lines(1:n,      rep(v.upper, n),           col = "blue", lty = 2 )
}
ichart.Gibbs(m.s1)
ichart.Gibbs <- function(result){
v <- result$m.sic
n <- length(v)
n.half <- n/2
v.min    <- min(v)
v.sd     <- sd(v)
v.mean   <- mean(v)
v.upper  <- v.min + sqrt(10)*sqrt(v.sd^2 + (v.mean - v.min)^2)
v.min.half   <- min(v[1:n.half])
v.sd.half    <- sd(v[1:n.half])
v.mean.half  <- mean(v[1:n.half])
v.upper.half <- v.min.half + sqrt(10)*sqrt(v.sd.half^2 + (v.mean.half - v.min.half)^2)
plot(1:n, v, type = "l", xlab = "Generations", ylab = paste(result$info, "Values"),
main = paste("I-chart for the generated", result$info, "sequence"))
lines(1:n.half, rep(v.upper.half, n.half), col = "red",  lty = 3 )
lines(1:n,      rep(v.upper, n),           col = "blue", lty = 2 )
}
ichart.Gibbs(m.s1)
devtools::check()
devtools::build()
devtools::install()
devtools::install()
setwd("H:/UbuntuRv2/IBGS")
install.packages("IBGS_0.1.2.tar.gz", repos = NULL)
setwd("H:/UbuntuRv2/STC/Approach2/poisson")
setwd("H:/UbuntuRv2/STC/Final")
library(IBGS)
#data
STC <- read.csv("STC.csv")
#predictors
x   <- as.matrix(STC[,10:45])
colnames(x) <- c("DMSLP.Aug", "TMSLP.Aug",  "DMI.Aug",    "DMIE.Aug",    "DMIW.Aug",    "QBO.Aug",
"SOI.Aug",   "N12.Aug",    "N34.Aug",    "N3.Aug",      "N4.Aug",      "EMI.Aug",
"DMSLP.Sep", "TMSLP.Sep",  "DMI.Sep",    "DMIE.Sep",    "DMIW.Sep",    "QBO.Sep" ,
"SOI.Sep"  , "N12.Sep" ,   "N34.Sep" ,   "N3.Sep" ,     "N4.Sep" ,     "EMI.Sep" ,
"DMSLP.Oct", "TMSLP.Oct",  "DMI.Oct" ,   "DMIE.Oct" ,   "DMIW.Oct",    "QBO.Oct" ,
"SOI.Oct" ,  "N12.Oct" ,   "N34.Oct",    "N3.Oct"  ,    "N4.Oct" ,     "EMI.Oct")
i = 1
#response variables
w <- STC[,2:9]
n <- dim(x)[1]
p <- dim(x)[2]
#Gibbs sampler results
TC.gs    <- list()
TC.gs[[i]] <- GibbsSampler(y, x, n.models = 5, k =  2,
info = "AICc", family = "poisson")
y <- w[,i]
TC.gs[[i]] <- GibbsSampler(y, x, n.models = 5, k =  2,
info = "AICc", family = "poisson")
#' I-chart for the generated sequence
#'
#' @param result a list of results
#'
#' @export
ichart.Gibbs <- function(result){
v <- result$m.sic
n <- length(v)
n.half <- n/2
v.min    <- min(v)
v.sd     <- sd(v)
v.mean   <- mean(v)
v.upper  <- v.min + sqrt(10)*sqrt(v.sd^2 + (v.mean - v.min)^2)
v.min.half   <- min(v[1:n.half])
v.sd.half    <- sd(v[1:n.half])
v.mean.half  <- mean(v[1:n.half])
v.upper.half <- v.min.half + sqrt(10)*sqrt(v.sd.half^2 + (v.mean.half - v.min.half)^2)
plot(1:n, v, type = "l", xlab = "Generations", ylab = paste(result$info, "Values"),
main = paste("I-chart for the generated", result$info, "sequence"))
lines(1:n.half, rep(v.upper.half, n.half), col = "red",  lty = 3 )
lines(1:n,      rep(v.upper, n),           col = "blue", lty = 2 )
}
ichart.Gibbs(TC.gs[[1]])
devtools::check()
devtools::check()
