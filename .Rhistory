install.packages("devtools")
install.packages("roxygen2")
profvis::profvis({  p <- model$df.null - model$df.residual})
acprob <- function(mod_1, mod_2, k, gamma, p0, info = c("AIC", "BIC", "AICc", "exBIC")){
switch(info,
AIC    = sigmoid(-AIC(mod_2))   + AIC(mod_1), k),
AICc   = sigmoid(-AICc(mod_2))  + AICc(mod_1), k),
BIC    = sigmoid(-BIC(mod_2))   + BIC(mod_1), k),
exBIC  = sigmoid(-exBIC(mod_2)) + exBIC(mod_1), k)
}
acprob <- function(mod_1, mod_2, k, gamma, p0, info = c("AIC", "BIC", "AICc", "exBIC")){
switch(info,
AIC    = sigmoid(-AIC(mod_2)   + AIC(mod_1), k),
AICc   = sigmoid(-AICc(mod_2)  + AICc(mod_1), k),
BIC    = sigmoid(-BIC(mod_2)   + BIC(mod_1), k),
exBIC  = sigmoid(-exBIC(mod_2) + exBIC(mod_1), k)
)
}
load("H:/UbuntuRv2/Gibbs-sampler-algorithm/block/simu_case1_ibgs_0.RData")
m1 <- glm(y~x[,1])
m2 <- glm(y~x[,2])
ac.ratio <- function(mod_1, mod_2, k, gamma, p0, info = c("AIC", "BIC", "AICc", "exBIC")){
switch(info,
AIC    = sigmoid(-AIC(mod_2)   + AIC(mod_1), k),
AICc   = sigmoid(-AICc(mod_2)  + AICc(mod_1), k),
BIC    = sigmoid(-BIC(mod_2)   + BIC(mod_1), k),
exBIC  = sigmoid(-exBIC(mod_2) + exBIC(mod_1), k)
)
}
ac.ratio(m1,m2,info = "AIC")
#' sigmoid function to calculate the acceptance probability
#'
#' @param dx the difference of model selection criteria
#' @param k  the tuning parameter
#'
#' @return
#' @export
#'
#' @examples
sigmoid <- function(dx,k){
p <- exp(k * dx)
return(min(c(1,p)))
}
ac.ratio(m1,m2,info = "AIC")
ac.ratio(m1,m2, k = 1, info = "AIC")
ac.ratio(m1,m2, k = 1, info = "BIC")
ac.ratio(m1,m2, k = 1, info = "exBIC")
ac.ratio(m1,m2, k = 1, gamma = 0.5, info = "exBIC")
m1$aic
m1$df.null- m1$df.residual
m1$rank
m1$model
dim(m1$model)[1]
#' The corrected AIC function
#'
#' @param model the selected model
#'
#' @return
#' @export
#'
#' @examples
AICc <- function(model){
k <- model$df.null - model$df.residual
n <- dim(model$model)[1]
return(model$aic + 2*k*(k+1)/(n-k-1))
}
AICc(m1)
AIC(m1)
AICcmodavg::AICc(m1)
AICcmodavg::AICc(m1) - AIC(m1)
2*2*3/197
2*2*3/197*2
4/198
dim(m1$model)[1]
0.122449*198
0.122449*198/2
2*3*4/196
m1$xlevels
m1$family
#' The corrected AIC function
#'
#' @param model the selected model
#'
#' @return
#' @export
#'
#' @examples
AICc <- function(model){
k <- switch(model$family,
gaussian = model$df.null - model$df.residual + 2,
binomial = model$df.null - model$df.residual,
poisson  = model$df.null - model$df.residual)
n <- dim(model$model)[1]
return(model$aic + 2*k*(k+1)/(n-k-1))
}
AICc(m1)
m1$family
attr(m1$family)
unlist(m1$family)
m1$family$family
#' The corrected AIC function
#'
#' @param model the selected model
#'
#' @return
#' @export
#'
#' @examples
AICc <- function(model){
k <- switch(model$family$family,
gaussian = model$df.null - model$df.residual + 2,
binomial = model$df.null - model$df.residual,
poisson  = model$df.null - model$df.residual)
n <- dim(model$model)[1]
return(model$aic + 2*k*(k+1)/(n-k-1))
}
AICc(m1)
AICcmodavg::AICc(m1)
w <- exp(y)
m3 <- glm(w~x[,1], family = poisson())
m3
AICc(m3)
AICcmodavg::AICc(m3)
m4 <- glm(w~x[,1:10], family = poisson())
m4
w = exp(rowSums(x[,1:10]))
m4 <- glm(w~x[,1:10], family = poisson())
w
w = exp(rowSums(x[,1:5]))
m4 <- glm(w~x[,1:5], family = poisson())
m4
warnings(10)
w = rpois(200, exp(rowSums(x[,1:5])))
m4 <- glm(w~x[,1:5], family = poisson())
m4
AICc(m4)
AICcmodavg::AICc(m4)
AIC(m4)
638.293 - 637.8578
0.4352*194
2*6*7/193
#' The corrected AIC function
#'
#' @param model the selected model
#'
#' @return
#' @export
#'
#' @examples
AICc <- function(model){
k <- switch(model$family$family,
gaussian = model$df.null - model$df.residual + 2,
binomial = model$df.null - model$df.residual + 1,
poisson  = model$df.null - model$df.residual + 1)
print(k)
n <- dim(model$model)[1]
return(model$aic + 2*k*(k+1)/(n-k-1))
}
AICc(m4)
#' The corrected AIC function
#'
#' @param model the selected model
#'
#' @return
#' @export
#'
#' @examples
AICc <- function(model){
k <- switch(model$family$family,
gaussian = model$df.null - model$df.residual + 2,
binomial = model$df.null - model$df.residual + 1,
poisson  = model$df.null - model$df.residual + 1)
n <- dim(model$model)[1]
return(model$aic + 2*k*(k+1)/(n-k-1))
}
AICc(m4)
AICcmodavg::AICc(m4)
#' the function to burn first samples out
#'
#' @param m the model sequence matrix
#' @param l the number of burned samples
#'
#' @return
#' @export
#'
#' @examples
burn.seq <- function(m, l){
return(m[(nrow(m)-l+1),])
}
burn.seq(x,100)
dim(burn.seq(x,100))
#' the function to burn first samples out
#'
#' @param m the model sequence matrix
#' @param l the number of burned samples
#'
#' @return
#' @export
#'
#' @examples
burn.seq <- function(m, l){
return(m[(nrow(m)-l+1):nrow(m),])
}
dim(burn.seq(x,100))
devtools::document()
devtools::document()
getwd()
setwd("H:/UbuntuRv2/IBGS/IBGS/R")
devtools::document()
setwd("H:/UbuntuRv2/IBGS/IBGS")
devtools::document(IBGS)
devtools::document()
devtools::document()
devtools::document()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
devtools::check()
r.index <- function(x, index, H){
x.r <- rep(0, length(x0))
for (i in 1:H) {
d <- sum(index == i)
x.r[index == i] <- x[1:d]
x <- x[-(1:d)]
}
return(x.r)
}
sample(x =5. size = 100, replace = T, prob = rep(0.2,5))
t = sample(x =5, size = 100, replace = T, prob = rep(0.2,5))
t
x <- 1:100
y <- vector()
for(i in 1:5){
y <- c(y, x[t == i])
}
y
x
r.index(y,t,5)
r.index <- function(x, index, H){
x.r <- rep(0, length(x))
for (i in 1:H) {
d <- sum(index == i)
x.r[index == i] <- x[1:d]
x <- x[-(1:d)]
}
return(x.r)
}
r.index(y,t,5)
#' @return a matrix of generated candidate model samples
#' @export
#'
#' @examples
#' x <- matrix(rnorm(1000), ncol = 10);
#' y <- rowSums(x[,1:5]) + rnorm(100)
#' m.s <- GibbsSampler(y,x,x2=vector(), s.model = rep(1,10), len = 100,
#'        k=1, info = "BIC", family = "gaussian")
#' print(colSums(m.s)/100)
#'
GibbsSampler <- function(y, x1, x2, s.model, len, k, gamma, p0, info, family){
z  <- as.data.frame(cbind(y,x1,x2))
colnames(z)[1] <- "y"
p1 <- dim(x1)[2]
if(is.null(dim(x2))){
p2 <- 0
}else
p2 <- dim(x2)[2]
s.index <- c(s.model, rep(1,p2))
m.models <- c(1, s.index)
m.temp <- glm(y ~ .,family = family, data = z[,c(1,s.index)==1])
j <- 0
while(j < 2*len){
for(i in 1:p1){
t.index    <- s.index
d.index    <- t.index
d.index[i] <- 1 - t.index[i]
if(0 < sum(d.index)){
m.curr <- m.temp
m.next <- glm(y ~ .,family = family, data = z[,c(1,d.index)==1])
A  <- ac.ratio(m.curr, m.next, k, gamma, p0, info = info)
mu <- runif(1)
if(mu < A){
t.index[i] <- 1 - t.index[i]
m.temp     <- m.next
}
else{
m.temp     <- m.curr
}
s.index      <- t.index
}
else{
s.index      <- t.index
}
}
#store the sequence in a matrix
m.models <- rbind(m.models, c(1,s.index))
j <- j + 1
}
return(burn.seq(m.models, len))
}
devtools::check()
BlockGibbsSampler.step1 <- function(y, x1, x2, h, len, k, gamma, p0, info, family){
index    <- sample(x = h, size = dim(x1)[2], replace = TRUE, prob = rep(1/h, h))
v.freq   <- foreach(i = 1:h, .combine=c) %dopar% {
xi            <- x1[, index == i]
pi            <- dim(xi)[2]
s.model       <- rep(1,pi)
m.matrix      <- GibbsSampler(y, xi, x2, s.model, len, k, gamma, p0, info, family)
v.prob        <- colSums(m.matrix)/len
v.prob[2:(pi+1)]
}
return(r.index(v.freq, index, h))
}
kappa()
kappa(1)
devtools::check()
devtools::check()
BlockGibbsSampler.step2 <- function(y, x1, x2, H, kapp, tau, len,
k, gamma, p0, info, family){
x  <- cbind(x1,x2)
z  <- as.data.frame(cbind(y,x1,x2))
colnames(z)[1] <- "y"
n  <- dim(x1)[1]
p1 <- dim(x1)[2]
if(is.null(dim(x2))){
p2 <- 0
}else
p2 <- dim(x2)[2]
h  <- ceiling(dim(x1)[2]/(min(H, n-p2)))
v.freq   <- BlockGibbsSampler.step1(y, x1, x2, h, len, k, gamma, p0, info, family)
x.s      <- cbind(x1[,order(v.freq, decreasing = TRUE)[1:kapp]], x2)
p.s      <- dim(x.s)[2]
s.index   <- rep(1, p.s)
m.matrix  <- GibbsSampler(y, x.s, x2 = vector(), s.index, len,
k, gamma, p0, info, family)
v.freq2    <- colSums(m.matrix)/len
if(sum(v.freq2[-1] > tau) > 1){
v.select   <- as.numeric(colnames(x.s)[v.freq2[-1] > tau])
}
else{
v.select   <- as.numeric(colnames(x.s))
}
return(sort(v.select))
}
devtools::check()
devtools::check()
a <- c(1,1,1,2,2,3,4,4,4,4,5,5,6)
table(a)
as.numeric(levels(as.data.frame(table(a))[,1]))
as.numeric(as.data.frame(table(a))[,1])
#' Calculate the weights based on the model selection criterion values
#'
#' @param sic a vector of model selection criterion values
#' @param k   the tuning parameter
#'
#' @return a sequence of model weights
#' @export
#'
#'
weight <- function(sic, k){
return(exp(-k*(sic - min(sic)))/sum(exp(-k*(sic - min(sic)))))
}
weight(a)
weight(a,1)
result.GibbsSampler <- function(m.matrix, y, x, n.models, info, family){
z <- as.data.frame(cbind(y,x))
colnames(z)[1] <- "y"
n <- dim(m.matrix)[1]
m.sic <- vector()
for(i in 1:n){
m.sic <- c(m.sic, v.sic(m.matrix[i,], y, x, info, family))
}
m.sic.df <- as.data.frame(table(m.sic))
m.sics <- as.numeric(m.sic.df[,1])
if(length(m.sics) < n.models)
n.models <- length(m.sics)
m.order <- order(m.sic, decreasing = FALSE)
m.index <- cumsum(m.sic.df[,2])
m.models <- list()
for (i in 1:n.models) {
model <- glm(y~., z[,m.matrix[m.order[m.index[i]],]==1], family = family)
m.models[[i]] <- model
}
m.sicc <- m.sics[1:n.models]
m.weights <- weight(m.sicc)
return(list(n.models = n.models,
m.sics   = m.sics,
m.seq    = m.matrix[,-1],
c.models = list(models  = m.models,
weights = m.weights),
info     = info,
family   = family
))
}
devtools::check()
devtools::install()
library(IBGS)
AICc(m1)
library(IBGS)
devtools::check()
?IBGS
?AICc
library(IBGS)
?BlockGibbsSampler
devtools::check()
devtools::check()
devtools::build()
devtools::install()
library(IBGS)
x <- matrix(rnorm(1000), ncol = 10);
y <- rowSums(x[,1:5]) + rnorm(100)
m.s <- GibbsSampler(y,x,x2=vector(), s.model = rep(1,10), len = 100,
k=1, info = "BIC", family = "gaussian")
remove.packages(IBGS)
library(IBGS)
weight
