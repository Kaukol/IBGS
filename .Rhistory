USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,],binomial(link="logit"))
Pred[i,COM] <- sum( c(1,E[i,])*(fit$coefficients) )
}
fit <- glm(y~E,binomial(link="logit"))
PRED[,COM] <- cbind(1,E)%*%(fit$coefficients)
}
w <- rep(0.5,len=KK)
print(head(Pred))
m = 3
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,],binomial(link="logit"))
Pred[i,COM] <- sum( c(1,E[i,])*(fit$coefficients) )
print(Pred[i,COM])
}
i=1
fit <- glm(y[-i]~E[-i,],binomial(link="logit"))
summary(fit)
cor(E)
View(AX)
z$Coriolis_parameter_absolute
tcg <- read.csv("TC_data_12h_AR_Matched.csv")
z1 <- tcg[,8:157]
z <- z1(,!colnames(z) == "Coriolis_parameter_absolute")
z <- z1(,!colnames(z1) == "Coriolis_parameter_absolute")
z <- z1[,!(colnames(z1) == "Coriolis_parameter_absolute")]
y <- z$y
x <- as.matrix(z[,-1])
n <- dim(x)[1]
p <- dim(x)[2]
index_train <- sample(x = 2, size = n, replace = TRUE, prob = c(0.8,0.2))
x_train <- x[index_train ==  1, ]
y_train <- y[index_train ==  1 ]
x_test <- x[index_train ==  2, ]
y_test <- y[index_train ==  2 ]
AX  <- x_train
y   <- y_train
p <- PP <- ncol(AX)
n <- dim(AX)[1]
COV <- rep(0,len=PP)
for(i in 1:PP){
fit <- glm(y~AX[,i],family=binomial())
COV[i] <- (summary(fit)$coefficients)[2,4]
}
a <- cbind(1:PP,COV)
COV <- a[order(a[,2],decreasing=F),1:2]
NN <- NumbPred <- 10 #The number of predictors
KK <- trunc(sum(COV[,2]<=0.01)/NN)
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,],binomial(link="logit"))
Pred[i,COM] <- sum( c(1,E[i,])*(fit$coefficients))
#print(i)
}
fit <- glm(y~E,binomial(link="logit"))
PRED[,COM] <- cbind(1,E)%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,],binomial(link="logit"))
Pred[i,COM] <- sum( c(1,E[i,])*(fit$coefficients) )
print(Pred[i,COM])
}
fit <- glm(y~E,binomial(link="logit"))
PRED[,COM] <- cbind(1,E)%*%(fit$coefficients)
}
w <- rep(0.5,len=KK)
print(head(Pred))
print(auc(y, Pred[,1]))
library(pROC)
print(auc(y, Pred[,1]))
print(auc(y, Pred[,2]))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
w <- model$par
Pred <- PRED%*%w
print(auc(y, Pred))
print(auc(y, as.vector(Pred)))
y.t <- y_test
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK); PRED.t <- matrix(0,n,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE]); E.t <- as.matrix(x_test[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,],binomial(link="logit"))
Pred[i,COM] <- sum( c(1,E[i,])*(fit$coefficients))
#print(i)
}
fit <- glm(y~E,binomial(link="logit"))
PRED[,COM] <- cbind(1,E)%*%(fit$coefficients)
PRED.t[,COM] <- cbind(1,E.t)%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,],binomial(link="logit"))
Pred[i,COM] <- sum( c(1,E[i,])*(fit$coefficients) )
}
fit <- glm(y~E,binomial(link="logit"))
PRED[,COM] <- cbind(1,E)%*%(fit$coefficients)
PRED.t[,COM] <- cbind(1,E.t)%*%(fit$coefficients)
}
w <- rep(0.5,len=KK)
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK); PRED.t <- matrix(0,n1,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE]); E.t <- as.matrix(x_test[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,],binomial(link="logit"))
Pred[i,COM] <- sum( c(1,E[i,])*(fit$coefficients))
#print(i)
}
fit <- glm(y~E,binomial(link="logit"))
PRED[,COM] <- cbind(1,E)%*%(fit$coefficients)
PRED.t[,COM] <- cbind(1,E.t)%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,],binomial(link="logit"))
Pred[i,COM] <- sum( c(1,E[i,])*(fit$coefficients) )
}
fit <- glm(y~E,binomial(link="logit"))
PRED[,COM] <- cbind(1,E)%*%(fit$coefficients)
PRED.t[,COM] <- cbind(1,E.t)%*%(fit$coefficients)
}
n1 <- dim(x_test)[1]
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK); PRED.t <- matrix(0,n1,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE]); E.t <- as.matrix(x_test[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,],binomial(link="logit"))
Pred[i,COM] <- sum( c(1,E[i,])*(fit$coefficients))
#print(i)
}
fit <- glm(y~E,binomial(link="logit"))
PRED[,COM] <- cbind(1,E)%*%(fit$coefficients)
PRED.t[,COM] <- cbind(1,E.t)%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,],binomial(link="logit"))
Pred[i,COM] <- sum( c(1,E[i,])*(fit$coefficients) )
}
fit <- glm(y~E,binomial(link="logit"))
PRED[,COM] <- cbind(1,E)%*%(fit$coefficients)
PRED.t[,COM] <- cbind(1,E.t)%*%(fit$coefficients)
}
w <- rep(0.5,len=KK)
print(head(Pred))
print(auc(y, Pred[,1]))
print(auc(y, Pred[,2]))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
w <- model$par
Pred.0 <- PRED%*%w
print(auc(y, as.vector(Pred.0)))
Pred.t <- PRED.t%*%w
print(auc(y.t, as.vector(Pred.t)))
setwd("H:/UbuntuRv2/Gibbs-sampler-algorithm/MA-Tingjin5")
### linear case 1 - (CV-MA)
#ensure empty environment
rm(list = ls())
library(pROC)
library(MASS)
set.seed(101)
#simulation set up
#200 train samples and 200 test samples with 1000 predictors
n <- 500
p <- 1000
rho <- 0.5
#correlation matrix
#correlation between any two predictors is 0.5 except x4,x5
M1   <- rho + (1-rho)*diag(p/2)
#correlation between x4 and others is 1/sqrt(0.5) except x5
M1[,4]  <- 1/sqrt(2)
M1[4,]  <- 1/sqrt(2)
M1[4,4] <- 1
M2 <- diag(1,p/2)
for (i in 1:p/2)
{
for (j in 1:i)
{
M2[j,i] <- rho^{i-j}
M2[i,j] <- M2[j,i]
}
}
#coefficients
#with 4 preselected equal = 1 and others are randomly generated from N(0,1)
s <- 10
beta <- 2*c(1,1,1,1,1, rnorm(s-5))
AUC <- vector()
j <- 0
while(j < 100){
#data matrix
x1 <- mvrnorm(n,rep(0,p/2),M1)
x2 <- mvrnorm(n,rep(0,p/2),M2)
AX <- cbind(x1,x2)
w <- 2 + AX[,c(1:4,1:6+p/2)]%*%beta + sin(rnorm(n)*pi) + cos(rnorm(n)*pi)
q <- exp(w)/(1+exp(w))
y <- rbinom(n,1,q)
p <- PP <- ncol(AX)
######################################
COV <- rep(0,len=PP)
for(i in 1:PP){
fit <- glm(y~AX[,i],family=binomial())
COV[i] <- (summary(fit)$coefficients)[2,4]
}
a <- cbind(1:PP,COV)
COV <- a[order(a[,2],decreasing=F),1:2]
#print(COV)
NN <- NumbPred <- 10 #The number of predictors
#KK <- trunc(sum(COV[,2]<=0.01)/NN)
KK <- 10
print(c(NN,KK))
######################################
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
}
######################################
w <- rep(0.5,len=KK)
print(head(Pred))
print(auc(y, Pred[,1]))
print(auc(y, Pred[,2]))
print(cor.test(y, Pred[,1]))
print(cor.test(y, Pred[,2]))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
w <- model$par
######################################
Pred <- PRED%*%w
EProb <- exp(Pred)/(1+exp(Pred))
AUC <- c(AUC, auc(y, EProb))
j <- j+1
print(j)
}
AUC <- vector()
j <- 0
while(j < 100){
#data matrix
x1 <- mvrnorm(n,rep(0,p/2),M1)
x2 <- mvrnorm(n,rep(0,p/2),M2)
AX <- cbind(x1,x2)
w <- 5 + AX[,c(1:4,1:6+p/2)]%*%beta + sin(rnorm(n)*pi) + cos(rnorm(n)*pi)
q <- exp(w)/(1+exp(w))
y <- rbinom(n,1,q)
p <- PP <- ncol(AX)
######################################
COV <- rep(0,len=PP)
for(i in 1:PP){
fit <- glm(y~AX[,i],family=binomial())
COV[i] <- (summary(fit)$coefficients)[2,4]
}
a <- cbind(1:PP,COV)
COV <- a[order(a[,2],decreasing=F),1:2]
#print(COV)
NN <- NumbPred <- 10 #The number of predictors
#KK <- trunc(sum(COV[,2]<=0.01)/NN)
KK <- 10
print(c(NN,KK))
######################################
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
}
######################################
w <- rep(0.5,len=KK)
print(auc(y, Pred[,1]))
print(auc(y, Pred[,2]))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
w <- model$par
######################################
Pred <- PRED%*%w
EProb <- exp(Pred)/(1+exp(Pred))
AUC <- c(AUC, auc(y, EProb))
j <- j+1
print(j)
}
COV[1:50]
cor(y, x[,5])
cor(y, AX[,4])
cor(y, AX[,3])
cor(y, AX[,2])
cor(y, AX[,1])
a[1:20,]
t(a[1:100,])
summary(glm(y~AX[,1], binomial()))
sum(y)
j <- 0
while(j < 10){
#data matrix
x1 <- mvrnorm(n,rep(0,p/2),M1)
x2 <- mvrnorm(n,rep(0,p/2),M2)
AX <- cbind(x1,x2)
w <- -5 + AX[,c(1:4,1:6+p/2)]%*%beta + sin(rnorm(n)*pi) + cos(rnorm(n)*pi)
q <- exp(w)/(1+exp(w))
y <- rbinom(n,1,q)
p <- PP <- ncol(AX)
######################################
COV <- rep(0,len=PP)
for(i in 1:PP){
fit <- glm(y~AX[,i],family=binomial())
COV[i] <- (summary(fit)$coefficients)[2,4]
}
a <- cbind(1:PP,COV)
COV <- a[order(a[,2],decreasing=F),1:2]
#print(COV)
NN <- NumbPred <- 10 #The number of predictors
#KK <- trunc(sum(COV[,2]<=0.01)/NN)
KK <- 10
print(c(NN,KK))
######################################
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
}
######################################
w <- rep(0.5,len=KK)
print(auc(y, Pred[,1]))
print(auc(y, Pred[,2]))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
w <- model$par
######################################
Pred <- PRED%*%w
EProb <- exp(Pred)/(1+exp(Pred))
AUC <- c(AUC, auc(y, EProb))
j <- j+1
print(j)
}
### linear case 1 - (CV-MA)
#ensure empty environment
rm(list = ls())
library(pROC)
library(MASS)
#simulation set up
#200 train samples and 200 test samples with 1000 predictors
n <- 500
p <- 1000
rho <- 0.5
#correlation matrix
#correlation between any two predictors is 0.5 except x4,x5
M1   <- rho + (1-rho)*diag(p/2)
#correlation between x4 and others is 1/sqrt(0.5) except x5
M1[,4]  <- 1/sqrt(2)
M1[4,]  <- 1/sqrt(2)
M1[4,4] <- 1
M2 <- diag(1,p/2)
for (i in 1:p/2)
{
for (j in 1:i)
{
M2[j,i] <- rho^{i-j}
M2[i,j] <- M2[j,i]
}
}
#coefficients
#with 4 preselected equal = 1 and others are randomly generated from N(0,1)
s <- 10
beta <- 2*c(1,1,1,1,1, rnorm(s-5))
AUC <- vector()
#data matrix
x1 <- mvrnorm(n,rep(0,p/2),M1)
x2 <- mvrnorm(n,rep(0,p/2),M2)
AX <- cbind(x1,x2)
w <- AX[,c(1:4,1:6+p/2)]%*%beta + 3*sin(rnorm(n)*pi) + 3*cos(rnorm(n)*pi)
q <- exp(w)/(1+exp(w))
y <- rbinom(n,1,q)
p <- PP <- ncol(AX)
COV <- rep(0,len=PP)
for(i in 1:PP){
fit <- glm(y~AX[,i],family=binomial())
COV[i] <- (summary(fit)$coefficients)[2,4]
}
a <- cbind(1:PP,COV)
COV <- a[order(a[,2],decreasing=F),1:2]
NN <- NumbPred <- 10 #The number of predictors
#KK <- trunc(sum(COV[,2]<=0.01)/NN)
KK <- 10
print(c(NN,KK))
Pred <- matrix(0,n,KK); PRED <- matrix(0,n,KK)
COM <- 1
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
for(m in 2:KK){
COM <- m
USE <- COV[(NN*(COM-1)+1):(NN*COM),1]; E <- as.matrix(AX[,USE])
for(i in 1:n){
fit <- glm(y[-i]~E[-i,]+0,binomial(link="logit"))
Pred[i,COM] <- sum( E[i,]*(fit$coefficients) )
}
fit <- glm(y~E+0,binomial(link="logit"))
PRED[,COM] <- E%*%(fit$coefficients)
}
w <- rep(0.5,len=KK)
print(auc(y, Pred[,1]))
print(auc(y, Pred[,2]))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w)) + 1e-6
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
if(Pi==1){
Pi = Pi - 1e-6
}
else Pi = Pi + 1e-6
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
Stein <- function(w){
Pi <- exp(Pred%*%w)/(1+exp(Pred%*%w))
if(sum(Pi==1)>0){
Pi = Pi - 1e-6
}
else Pi = Pi + 1e-6
ss <- -sum( y*log(Pi)+(1-y)*log(1-Pi) )
ss
}
model <- optim(w,fn=Stein,method="L-BFGS-B",lower=rep(0,len=m),upper=rep(1,len=m))
load("H:/UbuntuRv2/IBGS/test.RData")
setwd("H:/UbuntuRv2/IBGS/IBGS")
remove.packages(IBGS)
source('H:/UbuntuRv2/IBGS/IBGS/R/gibbs.R', echo=TRUE)
source('H:/UbuntuRv2/IBGS/IBGS/R/gibbs.R', echo=TRUE)
devtools::check()
